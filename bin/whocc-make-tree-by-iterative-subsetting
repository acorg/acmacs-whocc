#! /usr/bin/env python3
import sys, os, re, datetime, subprocess, shutil, concurrent.futures, time, random, logging
from pathlib import Path
sys.path[:0] = [os.path.join(os.environ["ACMACSD_ROOT"], "py")]
import acmacs

class Error (RuntimeError): pass

sSeqeunceLength = {             # aa's
    "H1": 549,
    "H3": 550,
    "BVIC": 570,
    "BYAM": 570
    }

sDeletionsThreshold = { # aa
    "H1": 1,
    "H3": 1,
    "BVIC": 3,
    "BYAM": 3
    }

sBaseSeq = {
    "H1": "AH1N1/CALIFORNIA/7/2009_h87A2A7F3",
    "H3": "",
    "BVIC": "",
    "BYAM": ""
    }

sStartDate = {
    "H1": "2009",
    "H3": "",
    "BVIC": "",
    "BYAM": ""
    }

# ======================================================================

def main(args):
    subtype = args.subtype.upper()
    nuc_length = sSeqeunceLength[subtype] * 3
    now = datetime.datetime.now()
    years_ago = now - datetime.timedelta(days=366*3) # 3 years

    def parse_date(date):
        for fm in ["%Y-%m-%d", "%Y-%m", "%Y"]:
            try:
                return datetime.datetime.strptime(date, fm)
            except ValueError:
                pass
        return today - datetime.timedelta(days=366*100) # 100 years ago

    def mark_for_removal(subset, first, after_last):
        # keep most recent, do not remove isolated within last two years
        to_remove = set(range(first, after_last))
        to_keep = None
        for ind in to_remove:
            if not to_keep or subset[to_keep].date() < subset[ind].date():
                to_keep = ind
        to_remove.discard(to_keep)
        to_keep_recent = set(ind for ind in to_remove if parse_date(subset[ind].date()) >= years_ago)
        return sorted(to_remove - to_keep_recent)

    subset = (acmacs.seqdb().all()
              .filter_human()
              .filter_subtype(args.subtype)
              .remove_nuc_duplicates()
              .filter_dates(start=sStartDate[subtype])
              .filter_out_with_deletions(sDeletionsThreshold[subtype])
              .filter_out_with_front_back_deletions(length=nuc_length)
              .remove_nuc_duplicates_by_aligned_truncated(mark_for_removal, truncate_at=nuc_length)
              .sort("date"))
    subset.fasta()
    print(f"num seq: {len(subset)}")

# ======================================================================

import argparse, traceback

try:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '-v', '--debug', action='store_const', dest='loglevel', const=logging.DEBUG, default=logging.INFO, help='Enable debugging output.')

    parser.add_argument("subtype", choices=["h1", "h3", "bvic", "byam"])

    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel, format="%(levelname)s %(asctime)s: %(message)s")
    exit_code = main(args)
except Error as err:
    logging.error(err)
    exit_code = 1
except Exception as err:
    logging.error(f"{err}\n{traceback.format_exc()}")
    exit_code = 1
exit(exit_code)

# ======================================================================
### Local Variables:
### eval: (if (fboundp 'eu-rename-buffer) (eu-rename-buffer))
### End:
