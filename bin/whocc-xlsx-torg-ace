#! /usr/bin/env python3
# -*- Python -*-

"""
Converts xlsx to torg, waits for torg editing, converts it to ace
"""

import sys, os, pprint, subprocess, re, shutil, time, signal, datetime, collections
from pathlib import Path
sys.path[:0] = [str(Path(os.environ["ACMACSD_ROOT"]).resolve().joinpath("py"))]
import logging; module_logger = logging.getLogger(__name__)

class Error (Exception): pass

# ======================================================================

def main(args):
    names = subprocess.check_output(["whocc-xlsx-to-torg", "-n", args.source[0]]).decode("utf-8").strip().split("\n")
    output_dirs = frozenset(detect_dir(name) for name in names)
    if len(output_dirs) != 1:
        raise RuntimeError(f"None or multiple output dirs {output_dirs} inferred from {name}")
    output_dir = next(iter(output_dirs))
    check_output_names(names, output_dir=output_dir)
    copy_xlsx(args.source[0], output_dir.joinpath(make_xlsx_name(names)))
    subprocess.check_call(["whocc-xlsx-to-torg", "-o", output_dir, args.source[0]])
    if len(names) == 1:
        p
    else:
        p
        
# ----------------------------------------------------------------------

def detect_dir(name):
    subtype, lab, assay, date = name.split("-")
    try:
        dir = Path("~/ac/tables-store").expanduser()
        if subtype in ["b", "bvic", "byam"]:
            dir = dir.joinpath("B")
        elif subtype == "h1":
            dir = dir.joinpath("H1PDM")
        elif subtype == "h3":
            dir = dir.joinpath("H3")
        else:
            raise Error(f"unknown subtype {subtype}")
        if lab == "crick":
            lab_dir = "NIMR"
        elif lab == "vidrl":
            lab_dir = "MELB"
        else:
            lab_dir = lab.upper()
        dir = dir.joinpath(lab_dir)
        if lab == "vidrl":
            if subtype == "bvic":
                dir  = dir.joinpath("victoria")
            elif subtype == "byam":
                dir  = dir.joinpath("yamagata")
    except Exception as err:
        dir = Path("/d")
        module_logger.warning(f"cannot infer target dir, \"{dir}\" is used: {err}")
    return dir

# ----------------------------------------------------------------------

def make_xlsx_name(names):
    if len(names) == 1:
        return f"{next(iter(names))}.xlsx"
    else:
        names_sorted = sorted(names)
        return f"{names_sorted[0]}-{names_sorted[-1].split('-')[-1]}.xlsx"

# ----------------------------------------------------------------------

def check_output_names(names, output_dir):
    num_exist = 0
    def check(name):
        nonlocal num_exist
        path = output_dir.joinpath(name)
        if path.exists():
            num_exist += 1
            return f"*** {path}"
        else:
            return f"    {path}"
    msg = "\n".join(check(nam) for nam in [make_xlsx_name(names)] + [f"{nn}.torg" for nn in names])
    if num_exist:
        raise Error(f"{num_exist} file(s) marked with *** already exist(s):\n{msg}")

# ----------------------------------------------------------------------

def copy_xlsx(source, xlsx_name):
    module_logger.info(f"{source} -> {xlsx_name}")
    shutil.copyfile(source, xlsx_name)

# ----------------------------------------------------------------------

# def main(args):
#     writer = read_xlsx(args.source[0])
#     writer.process()
#     target_dir = writer.target_dir()
#     target_prefix = writer.target_prefix()
#     # if target_dir.joinpath(target_prefix + ".xlsx").exists() or target_dir.joinpath(target_prefix + ".xls").exists() or target_dir.joinpath(target_prefix + ".torg").exists() or target_dir.joinpath(target_prefix + ".ace").exists():
#     #     subprocess.check_call(f"ls -l {target_dir.joinpath(target_prefix)}*", shell=True)
#     #     raise RuntimeError("target already exists")
#     shutil.copyfile(args.source[0], target_dir.joinpath(target_prefix + ".xlsx"))
#     torg_filename = target_dir.joinpath(target_prefix + ".torg")
#     with torg_filename.open("w") as torg:
#         writer.generate_header(torg)
#         writer.generate_body(torg)
#     print("target:", target_dir, target_prefix)
#     # subprocess.check_call(["emacsclient", "-n", str(torg_filename)])
#     subprocess.check_call(["emacsclient", "-q", "-e", f"(progn (find-file \"{torg_filename}\") (forward-line 10) (org-cycle) (forward-line 0) (save-buffer))"])
#     if args.stop_on_torg:
#         return
#     # writer.generate_header()
#     # pprint.pprint(writer.rows, width=200)
#     signal.signal(signal.SIGHUP, sig_handler)
#     while True:
#         # print("wating for SIGHUP")
#         try:
#             time.sleep(60 * 60)
#         except KeyboardInterrupt:
#             break
#         except Exception as err:
#             # print(err)
#             pass
#         make_ace(torg_filename, target_dir.joinpath(target_prefix + ".ace"))

# ----------------------------------------------------------------------

def make_ace(source, target):
    print(f"\n{'=' * 150}\n{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n{source}\n{target}\n\n")
    subprocess.run(f"chart-org-table-to-ace '{source}' '{target}' && chart-fix-names-passages '{target}' '{target}' && chart-table '{target}'", shell=True)

def sig_handler(signo, stack):
    raise RuntimeError(f"SIG {signo}")

# ======================================================================

import argparse, traceback

try:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '--debug', action='store_const', dest='loglevel', const=logging.DEBUG, default=logging.INFO, help='Enable debugging output.')
    parser.add_argument('-t', action='store_true', dest='stop_on_torg', default=False, help='Stop after generating torg file.')

    parser.add_argument("source", nargs=1)

    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel, format="%(levelname)s %(asctime)s: %(message)s")
    exit_code = main(args)
except Error as err:
    logging.error(str(err))
    exit_code = 1
except Exception as err:
    logging.error('{}\n{}'.format(err, traceback.format_exc()))
    exit_code = 1
exit(exit_code)

# ======================================================================
### Local Variables:
### eval: (if (fboundp 'eu-rename-buffer) (eu-rename-buffer))
### End:
